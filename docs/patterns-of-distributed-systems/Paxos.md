# Paxos

使用两个共识建立阶段，以达到安全共识，即使节点断开。

## 问题

Paxos 算法是由[莱斯利·兰波特(Leslie Lamport)](http://lamport.org/)开发的，发表在他 1998 年的论文 [The Part-Time 议会(Parliament)](http://lamport.azurewebsites.net/pubs/pubs.html#lamport-paxos) 中。Paxos 工作在三个阶段，以确保多个节点在部分网络或节点故障的情况下还能达成一致性。**前两个阶段的作用是围绕一个值建立共识，然后最后一个阶段将该共识传递给其余的副本**。

- 准备阶段(Prepare)：建立最新的[生成时钟](Generation-Clock.md)，并收集已经接受的值。
- 接受阶段(Accept)：为这一代的副本提议一个可接受的值。
- 提交阶段(Commit)：告诉所有副本已经决定选择其中一个值了。

在第一个阶段里（称为准备阶段），节点会提出一个值（称为提议者[proposer]）联系在集群中其它节点（称为接受者[acceptors]），并询问它们是否选择这个值（即投票）。**一旦这些接受者已经准备就绪，并达到预定的法定人数（一般是奇数），提议者就进入第二阶段**。在第二个阶段(称为接受阶段)，提议者发送这个建议的值，**如果节点的仲裁[1]接受该值，就会选择该值**。在最后一个阶段(称为提交阶段)，提议者可以将选择的值提交给集群中的所有节点。

## 协议流程

Paxos 是个复杂难以理解的协议。我们将先从例子出发来展示这个协议的流程，然后深入研究它如何工作的一些细节。我们希望通过这个解释能直观地了解协议是如何工作的，而不是作为一个基于实现的全面描述。

这个有一个简短的协议摘要。

| 提议者(Proposer)                                             | 接受者(Acceptor)                                             |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 从[时钟生成器](Generation-Clock.md)中获取最新的数。发送一个已经准备好的请求，并携带这个生成的时钟数给所有接受者 |                                                              |
|                                                              | 如果这个准备请求的时钟数要比它本身的时钟数晚（大），它就会将值更新成更晚的值，并返回一个承诺响应(promise response)。如果它已经接受了一个提议，则会返回这个提议值。 |
| 当从接受者接收到法定数量(quorum)的这些 promise 时，它将查看这些响应中是否包含可接受的值。如果是，它将自己的提议值更改为那些携带更高的时钟数的返回的提议值。发送一个接收请求到所有接受者，这个请求携带这个时钟数和提议值。 |                                                              |
|                                                              | 如果接收请求的时钟数要比它已经承诺的变量更大，它就会将提议值存储作为它已接受的提议值，并响应给这个请求。 |
| 当它从法定数量的接受者接收到成功响应时，它会记录这个被选择的值并发送提交信息给所有节点。 |                                                              |

上面就是 pasox 最基本的规则，但是很难理解它们是如何结合起来形成有效的行为的。所以这里有一个例子来说明它是如何工作的。

![](../asserts/mfpaxos-initial-requests.png)

考虑一个有5个节点的集群：Athens, Byzantium, Cyrene,  Delphi, 以及 Ephesus。一个客户端连接了 Athens 节点，发出请求并设置名称为 "alice"。Athens 节点现在就需要启动一个 Paxos 交互来查看是有所有的节点都同意这个变更。Athens 就被称为提议者(Proposer)，那就是说 Athens 将向其它节点提议，集群的名称变更为 "alice"。此时在集群中所有的节点都是接受者(acceptors)，意思就是它们有能力接受提议。

就在 Athens 提议 "alice" 的相同时刻，Ephesus 节点也获得请求将集群的名称变更为 "elanor"。这就让 Ephesus 也成为了提议者。

![](../asserts/mfpaxos-initial-prepare.png)

在准备阶段，提议者首先发送一些预备请求，这些请求都包含一个生成编号。由于 Paxos 的目的是避免单点故障，所以我们不会从单代时钟中得出这个结论。相反，每个节点维护它自己的生成时钟，它将生成编号与节点 ID 结合在一起。节点 ID 用来打破这些关系(ties)，所以 [2,a] > [1,e] > [1,a]。每个接受者记录了到目前为止看到的最新承诺

| Node     | Athens | Byzantium | Cyrene | Delphi | Ephesus |
| -------- | ------ | --------- | ------ | ------ | ------- |
| 承诺代   | 1,a    | 1,a       | 0      | 1,e    | 1,e     |
| 接受的值 | none   | none      | none   | none   | none    |

因为在此之前它们没有看到任何请求，所以它们都返回一个承诺给调用者。我们称返回值为 "promise"，因为它表示接收方承诺不考虑任何比所承诺的更早一代时钟的消息。

![](../asserts/mfpaxos-a-prepare-c.png)

Athens 发送一个预备消息给 Cryene。当它收到一个返回的 promise 时，这就意味着它此时此刻收到了集群5个节点中的3个节点的 promise，这体现为投票法定人数([Quorum](Quorum.md))。Athens 现在从发送准备消息到发送接受消息。

Athens 可能无法从集群的大多数节点那里得到承诺。在这种情况下 Athens 通过增加生成时钟来重试准备请求。

| Node                | Athens | Byzantium | Cyrene | Delphi | Ephesus |
| ------------------- | ------ | --------- | ------ | ------ | ------- |
| promised generation | 1,a    | 1,a       | 1,a    | 1,e    | 1,e     |
| accepted value      | none   | none      | none   | none   | none    |

![](../asserts/mfpaxos-accept-ac.png)

Athens 现在会开始发送消息，其中包含了生成和提议的值。Athens 和 Byzantium 接受了这个提议。

## 原文链接

https://martinfowler.com/articles/patterns-of-distributed-systems/paxos.html
