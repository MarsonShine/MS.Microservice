# 键范围分区（Key-Range Partitions）

在已排序的键范围内对数据进行分区，以有效地处理范围查询。

## 问题

为了在集群节点中横跨节点分割数据，每个数据项都需要被映射到一个节点上。如果用户想要查询键的范围，只指定开始和结束键，则需要查询所有的分区才能获取到。为单个请求查询每个分区这并非最佳选择。

假设我们有一个键值存储的例子，我们可以使用基于散列的映射存储作者姓名。(在[固定分区](Fixed-Partition.md)中使用过)。

| Keys   | Hash                                    | 分区(Hash%总分区数) | Node |
| ------ | --------------------------------------- | ------------------- | ---- |
| alice  | 133299819613694460644197938031451912208 | 0                   | 0    |
| bob    | 63479738429015246738359000453022047291  | 1                   | 1    |
| mary   | 37724856304035789372490171084843241126  | 5                   | 1    |
| philip | 83980963731216160506671196398339418866  | 2                   | 2    |

如果用户想通过姓名的范围获取一系列值，比方说从首字符 a 到 f。如果使用键的散列将键映射到分区，则无法知道应该从哪个分区获取数据。那么必须要获取所有的分区中的数据

## 解决方案

**按顺序为键范围创建逻辑分区**。然后可以将分区映射到集群节点。要查询一定范围的数据，客户端可以从给定范围中获得所有包含键的分区，并只查询那些特定的分区以获得所需的值。

### 预定义键范围

如果我们已经知道了整个键空间和键的分布，则可以预先指定分区的范围。

让我们回到刚开始简单的键值存储的例子。在这个例子中，我们存储了作者的姓名和书籍。如果我们知道了作者姓名分布，那么我们就可以定义以特定字母划分分区——在这个例子中，我们说，'b'和'd'。

整个key的范围的开始和结束都需要特别标记。我们可以使用空字符串来标记最低和最高的键。范围就像下面一样：

| 键范围    | 描述                            |
| --------- | ------------------------------- |
| ("", "b"] | 覆盖了首字母a到b的姓名（包括b） |
| ("b", d]  | 覆盖了首字母b到d的姓名（包括d） |
| ("d", ""] | 覆盖其剩下的                    |



#### 客户端界面

#### 存储值

### 案例场景

### 自动分割范围

#### 计算范围大小和发现中间键

##### 案例场景

##### 基于负载分割

## 案例

